

--I/O 分析
SET STATISTICS IO ON 
/*
解释：

扫描计数(Scan Count)：执行扫描的次数，按照执行计划，表格被scan了几次。如果执行计划选择了并发运行，由多个thread
	同时做一个表的读取，每个thread 读其中的一部份，但是这里会显示所有thread的数目。也就是有几个trread 在并发做，
	就会有几个scan.
	
逻辑读取(logical reads)：从数据缓存读取的页数（数据是以页存储的，每一次存取都是以页为单位）。

物理读取(physical reads)：从磁盘读取的页数。

预读(read-ahead reads)：为进行查询而预读入缓存的页数

Lob逻辑读(lob logical reads) : 从数据缓存读取的Text Ntext ,image 或大值类型(varchar(max),nvarchar(max),varbinary(max)页的数目

Lob物理读(lob physical reads): 从磁盘读取的Text Ntext ,image 或大值类型页的数目

Lob预读(lob read-ahead reads): 为进行查询而放入缓存的Text Ntext ,image或大值类型页的数目


前提首先 确认是否是因为做了物理i/o而导致的性能不佳

数据存在从【磁盘】->【内存】->【读取】的过程,如果每次读取的数据都是在磁盘加载，速度肯定会慢很多。

语句的调优，要先确认数据页面能够事先缓存在内存里，如果这个问题得到解决，性能还不能达到要求，才有后续调优的必要。
如果这个问题解决后语句就能跑得足够快，那说明这个问题也是一个系统资源瓶颈问题，而不主要是语句本身的问题。

表'worktable' 工作表，通常在使用了order by ,group by ,散列联结和union 操作的查询中看到工作表，工作表在查询
的执行期间创建在'tempdb'上，并且在sqlserver完成操作时自动删除。
*/
--在独立环境下观察单个语句的IO原始情况---------------------------------------
USE AdventureWorks
GO

DBCC DROPCLEANBUFFERS --先清掉缓冲池里所有缓存的页面

SET STATISTICS IO ON 

SELECT DISTINCT ProductID,UnitPrice  
FROM dbo.salesorderdetail_test WHERE productid=777

SET STATISTICS IO OFF
/*

一，评估数据读取的性能
1，估算页面读取的时间

2，表被扫描的次数

3,读取的页大小：物理读取+预读 就是sqlserver 为了完成这句查询而从磁盘上读取的页数，如果不为0,说明数据没有缓存在内存里.
	(15096+139)*8KB=121880KB

4，读取的命中率：逻辑读取与预读次数的差，再次物理读取与(逻辑读取-预读)的差

二，语句的IO优化
当读取页面需要的时间很久，而第二次逻辑读取快很多，且一次加载的数据页占内存很大，则需要考虑对语句IO进和优化

1,逻辑读取页面数量过多，且最终返回的记录数又很少，说明语句访问的数据量冗余
解决：检查语句执行计划，检查是否应该调整索引，减少扫描的次数，缩小扫描范围,看能否减少其访问的数据量。

2，在生产环境下，一次加载的数据页占内存很大，说明内存中缓存的数据比较少
解决：a)了解语句和它访问的数据，是被经常使用的，还是偶尔使用的，对一偶尔使用，而访问的数据量又大，那sqlserver
		没有把它放到内存中也是正常的，对这样的语句，其运行时间里有物理i/o时间是合理的。
	 
	  b)检查生产服务器是否有内存瓶颈，是否存在经常换页的现象，如果生产环境下，内存没有瓶颈，或者很少有page out/page in的动作，
		那说明sqlserver能够把数据页维护在内存里，你看到的性能问题就不太会发生，所以无须太过优虑。

3，在生产环境下，物理读取的页并不多，但耗时还是比较久
解决：检查磁盘子系统的性能，提高其性能，是唯一解决方法了。

》》》》重要：
读操作总数由查询中涉及的所有表上的读取数量累加而得。单独表上执行的读操作数量可能变化很大，
这取决于从单独的表上请求的结果集大小和可用的索引。

通过逻辑读的数量优化前后的对比，可以看到优化的效果，有时执行的cpu和duration都会不一样，
但，读次数却是不变的。
*/
