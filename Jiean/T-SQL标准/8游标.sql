

--游标

--声明一个游标cur_obj
DECLARE cur_obj CURSOR
FORWARD_ONLY READ_ONLY	/*游标参数:forward_only-只允许从游标第一行开始向前移动，scroll则可以在结果集中前后移
动，read_only:只读，不能通过游标进行更新*/
FOR		--for定义游标对象
	SELECT session_id FROM sys.dm_exec_requests WHERE status IN('runnable','sleeping','runing')
	
--打开游标
OPEN cur_obj

--从游标中一次检索一行
FETCH NEXT 
FROM cur_obj INTO @session_id

--当存在游标就持续检索行
WHILE @@FETCH_STATUS=0
BEGIN 
	EXEC('dbcc outputbuffer('+@session_id+')')
	
	--提取下一行
	FETCH NEXT
	FROM cur_obj INTO @session_id
END

--关闭游标
CLOSE cur_obj

--释放游标
DEALLOCATE cur_obj

--游标的性能开销
/*
游标的开销取决于游标的特性:
1)定义游标的位置,通常有两种：客户端游标和服务器端游标。
客户端游标是创建于运行应用程序的电脑上，而不管这个应用是服务，数据访问层还是客户端前端，
可以工作于大部份的数据访问层(oledb提供者或odbc驱动程序),但只能仅向前的或静态游标
相比服务器端游标则是创建在服务器机器上，使用数据访问层或t-sql语句创建，可以是任何类型的游标。

2)游标的并发模式:
只读：read_only这是不可更新的游标，也就是在基表上不保留锁(为什么我可以更新)
乐观：optimistic 游标可以更新，在底层数据上不保留锁。
滚动锁：scroll_locks 在底层行上保持一个U锁,直到另一个游标行被讯取或游标关闭，这将阻止其他用户在游标读取底层行时
修改它，滚动锁并行性模式使游标可更新。

3)游标有4种类型
a)仅向前游标：forward_only 只支持从游标位置若罔闻向前滚动，允许通过游标的所有修改(插入，更新和删除)，而且这些游标反
映对底层表的所有修改，此种类型游标直接在基本上操作，来自底层表的行通常不被检索，直到游标行使用fetch操作读取。
(仅向前只读游标用fast_forward表示)
b)静态游标:Static 游标打开时在tempdb数据库中创建一个游标的快照，此后，静态游标在tempdb数据库上操作，数据在游标打开
时从底层表中读取，支持所有的滚动选项，但是是只读的，通过静态游标的数据修改不被允许，而且对底层表的修改不在游标中反映
c)键集驱动游标：KeySet 
d)动态游标：Dynamic 直接在基表上操作，底层表中的行在游标行使用fetch操作读取之前不被检索，支持除了fetch absoluten之外
的滚动选项，因为游标行成员不固定，允许通过游标的所有修改，而且所有对底层表的修改将被反映到游标中，不支持数所库API
游标实现的所有属性和方法。


性能比较

只读模式最低的锁开锁，在游标行读取之后就不在底层上保留S锁，其他用户不会被阻止访问该行，还可以在底层表上读取游标行
的select 语句上加nolock来避免读取时的S锁,缺点是底层表的内容不能通过游标修改,可以更改啊

乐观模式与只读模式相似，低锁开销，不保留S锁，通过游标对底层行进行修改需要操作查贸易所需要的该行上的排它权力，由于
采用行版本控制，招致了应用通过该游标的修改之前，确保当前底层行首先与原来读取的游标行比较(使用基于版本或基于值的
并发控制)所需的附加开锁，这也避免了通过游标进行的修改在无意中覆盖其他用户在游标行读取之后进行的修改。

滚动锁通过锁定与从游标中最后读取的行对应的底层行，游标保证底层行不会被其他用户修乞讨，这减少了乐观锁的版本控制开销，
而且，因为行不会被其他用户修改，应用程序不需检查行不匹配的错误。
*/

