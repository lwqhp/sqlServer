/*查询约束信息*/
select * from sys.key_constraints --保存主键约束和唯一约束的信息
select * from information_schema.check_constraints --check约束
select * from sys.foreign_keys -- 外键约束信息
select object_name(referenced_object_id) '主键表',
object_name(parent_object_id) '外键约束表',
 '约束列' =(select name from sys.columns where a.parent_object_id=object_id and a.parent_column_id=column_id),
* from sys.foreign_key_columns a

select * from information_schema.referential_constraints --外键约束的信息
select * from information_schema.constraint_column_usage--查看指定数据库中的所有约束的信息以及约束与列的对应关系
select * from information_schema.CONSTRAINT_TABLE_USAGE --查看数据库中的所有表中的约束信息
select * from INFORMATION_SCHEMA.table_constraints --获取约束的基本信息
select * from information_schema.KEY_COLUMN_USAGE --获取键约束列的信息


--约束
/*
约束按类型分为三类：
3.1)域约束：限制表的某一列或多列的值范围，比如,check约束
3.2)实体约束：这是对行的值进行限制，相同的值不能存在于其他的行中,主键约束,唯一约束
3.3)引用完整性约束：一个表中的一个列与某个表中的另一个列的值匹配,比如外键约束

约束命名
一般是简结明了，反映约束对象含义，名称
比如：约束类型_约束所在表名_字段(或含义)

规则和默认值
这是7.0以前的约束对象，他们不遵守ANSI标准，而且执行性能不如约束好。以不建议使用
约束是表的功能，本身没有存在形式，而规则和默认值是自身的实际对象，本身存在，约束是在表定义中定义的，而规则和
默认值是单独定义的，然后“绑定”到表上。

规则和默认值的独立对象特性使得它们可以在重用时不用重新定义。实际上，规则和默认值不限于绑定到表上，它们也可以绑
定到数据类型上，这有助于在不允许CLR数据类型 的sql server版本上创建高度功能化的用户自定义数据类型。

*/
--练习表
--状态表
CREATE TABLE sys_state(
	billStats INT,
	billStatsName VARCHAR(20),
	PRIMARY KEY(billStats) 
)
--添加状态表主键
ALTER TABLE sys_state ALTER COLUMN  billStats INT NOT NULL 
ALTER TABLE sys_state ADD CONSTRAINT PI_sys_state PRIMARY KEY(billStats)

--主表
CREATE TABLE sd_pur_ordermaster(
	companyID VARCHAR(20),
	billno VARCHAR(30),
	billStats INT 
)
go
--添加记录
INSERT INTO sys_state
SELECT 0,'未送审' UNION ALL
SELECT 1,'已送审' UNION ALL
SELECT 2,'未审核' UNION ALL
SELECT 4,'已审核' 


INSERT INTO sd_pur_ordermaster
SELECT 'PT','PI131117admin-001',0 UNION ALL 
SELECT 'PT','PI131117admin-002',1 UNION ALL 
SELECT 'PT','PI131117admin-003',2 UNION ALL 
SELECT 'PT','PI131117admin-004',4


--drop table sd_pur_ordermaster
--主键约束--------------------------------------------------------------------------
/*
1,定义表的时候创建主键(一种是在字段的后面加上，另一种是在最后定义,这种方式可以同时定义多个主键)
2,修改表结构的方式创建主键，但必须要加主键的字段是"不可为空"的
3，主键默认创建唯一，聚集索引，也可以在主键创建时显式指定创建一个非聚集索引。
*/
CREATE TABLE sd_pur_ordermaster(
	companyID VARCHAR(20) primary key, --列约束
	billno VARCHAR(30) ,
	billStats INT
)

CREATE TABLE sd_pur_ordermaster(
	companyID VARCHAR(20),
	billno VARCHAR(30),
	billStats INT,
	primary key(companyID,billno)--表约束，定义组合键，只能用表约束
)

alter table sd_pur_ordermaster alter column companyID VARCHAR(20) not null 
alter table sd_pur_ordermaster add constraint PK_sd_pur_ordermaster_companyID primary key(companyID)

go
--外键约束--------------------------------------------------------------------------------------
/*
用于保证引用了外键的表的信息完整性，约束主外建的一致性。

注：事实上我们并不建议用外键约束，不少程序员为了方便，保证引用了外键的表的数据不出现孤立数据(即主键表的数据已改)
在引用表上增加外键约束了事，但这样有个缺点，把本来程序里应该要做的检查丢给了数据库，增加了数据库的压力，2，隐藏了
业务逻辑，增加查找问题难度。

一些小应用，增加一个使用状态字段，可以管控不再需要的状态不显示出来。

外键约束有两种操作：
2.1)约束外键引用的一致性
2.2)外健的联级操作：修改主键表记录，会同时修改有外键约束的表记录
*/

--drop table sd_pur_ordermaster
CREATE TABLE sd_pur_ordermaster(
	companyID VARCHAR(30),
	billno VARCHAR(30),
	billStats INT FOREIGN KEY REFERENCES sys_state(billStats) --外键约束
)

--添加外键约束
ALTER TABLE sd_pur_ordermaster 
ADD CONSTRAINT FK_sd_pur_ordermaster --约束名
FOREIGN KEY(billStats) --定义作为外键列名
REFERENCES sys_state(billStats)--作为主键的表(列名)

--自表外键约束
/*参与构造外键关系的列必须定义为具有同一长度和小数位数
创建表的时候做表自引用 就可以忽略 foreign key 语句
表自引用的外键列 必须允许为null 要不是不允许插入的（避免对最初行的需要）

一般用于表现递归关系。
*/
alter table sd_pur_ordermaster 
add constraint FK_sd_pur_ordermaster2 
foreign key(billno) 
references sd_pur_ordermaster(companyID)--companyID要是主键

--删除已引用了的主键记录
DELETE sys_state --出错

--需要先删除外键约束记录中相应的记录后，才能删除主键记录
DELETE sd_pur_ordermaster WHERE billStats=4

DELETE sys_state WHERE billStats=4

--改主键名称(已引用了不能修改)
UPDATE sys_state SET billStats=5 WHERE billStats=2 --出错


-->>>>>2.2)联级操作
/*
约束未尾声明
on update cascade --联级更新，主键更新，同时更新受外键约束值
on delete cascade	--联级删除,主键删除，同时删除受外键约束值
*/

select * from sys_state
select * from sd_pur_ordermaster


--alter table sd_pur_ordermaster drop constraint FK_sd_pur_ordermaster
alter table sd_pur_ordermaster add constraint FK_sd_pur_ordermaster 
foreign key(billStats) references sys_state(billStats) on update cascade

alter table sd_pur_ordermaster add constraint FK_sd_pur_ordermaster 
foreign key(billStats) references sys_state(billStats) on delete cascade

update sys_state set billStats=5  where billStats=0
delete sys_state where billStats=1

--唯一约束---------------------------------------------------------------------------------------------------
/*
Unique
唯一约束和主键约束类似，区别在于主键约束要求列不能为nul,而unique约事则可以,且只能插入一个null值，在unique看来，
所有的null值都是长的一样的。
unique约束在创建的时候会创建一个基础表索引，这个索引可以是clustered或者是nonclustered ,但是在表已经存在聚集
索引的时候不能创建clustered索引
*/

CREATE TABLE sd_pur_ordermaster(billstats VARCHAR(20) NULL UNIQUE)
alter table sd_pur_ordermaster add constraint AK_sd_pur_ordermaster unique(billstats)

--Check约束---------------------------------------------------------------------------------------------------
/*
check不局限于一个特定的列，可以约束一个列，也可以通过某个列来约束另一个列
定义check约束使用的规则与where子句中的基本一样
语法：
check(logical_expression)
如果check的逻辑表达式计算为T,行就会被插入，如果check约束的表达式计算为F,行插入就会失败。
*/

--select * from sd_pur_ordermaster
alter table sd_pur_ordermaster add constraint CK_sd_pur_ordermaster check(billstats between 1 and 12)

--不检测原有数据是否符合约束条件
alter table sd_pur_ordermaster WITH NOCHECK ADD  constraint FK_sd_pur_ordermaster CHECK (billstats between 1 and 12)

insert into sys_state
select 12,'未知'

insert into sd_pur_ordermaster
select 'PT',	'PI131117admin-005',12 --受check约束

--禁止和启用约束

ALTER TABLE sd_pur_ordermaster NOCHECK CONSTRAINT  FK_sd_pur_ordermaster --临时禁止了约束的检查

--再次启用
ALTER TABLE sd_pur_ordermaster CHECK CONSTRAINT  FK_sd_pur_ordermaster

--禁用所有的check和foreign key 
ALTER TABLE sd_pur_ordermaster NOCHECK CONSTRAINT ALL 

--启用所有的check和foreign key
ALTER TABLE sd_pur_ordermaster CHECK CONSTRAINT ALL

/*
其它
between 1 and 12
like '[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9]'
in ('ups','fed ex','usps')
price >=0
shipdate >= orderdate
dateinsystem <= getdate()
*/


--default约束 --------------------------------------------------------------------------------
/*
1.如果插入的新行在定义了默认值的列上没有给出值，那么这个列上的数据就是定义的默认值
2.默认值只在insert语句中使用
3.如果插入的记录给出了这个列的值，那么该列的数据就是插入的数据
4.如果没有给出值，那么该列的数据总是默认值
*/
CREATE TABLE sd_pur_ordermaster(
	companyID VARCHAR(20),
	billno VARCHAR(30),
	billStats INT default(0)
)

alter table sd_pur_ordermaster add constraint DF_sd_pur_ordermaster  default(0) for billstats



--禁用约束------------------------------------------------------------------------------------------ 
/* 
primary key 和 unique约束 这对孪生约束是不能禁用的
从系统信息里可以看到：主键，unique是不能禁用的，check约束，外键约束是可以禁用的
*/
--查看约束状态
EXEC sys.sp_helpconstraint @objname = N'', -- nvarchar(776)
    @nomsg = '' -- varchar(5)


--禁用外键约束
--select * from sd_pur_ordermaster

insert into sd_pur_ordermaster
select 'PT','PI131117admin-006',6

alter table sd_pur_ordermaster nocheck constraint FK_sd_pur_ordermaster

--规则-------------------------------------------------------------------------------------------------
/*
　　规则和默认值的应用要早于CHECK和DEFAULT约束。他们是较老的SQL Server备用约束的一部分，当然也不是没有优点。自7.0版本之后，MicroSoft列出规则和默认值只是为了向后兼容，而不准备在以后继续支持这个特性。因此对于生成新代码时，应该使用约束。

　　规则、默认值与约束的本质区别是：约束是一个表的特征，本身没有存在形式，而规则和默认值是表和自身的实际对象，本身存在。约束是在表定义中定义的，而规则和默认值是单独定义，然后"绑定到"表上。

　　规则和默认值的独立对象特性使得它们可以在重用时不用重新定义。实际上，规则和默认值不限于被绑定到表上，它们也可以绑定到数据类型上。

*/
--查看哪些表和数据类型使用给定的规则或默认值 
EXEC sys.sp_depends  @objname = N'' -- nvarchar(776)


go
Create rule SalaryRule
as @salary >0;
sp_bindrule 'SalaryRule' , 'Employee.Salary' --这可以是表列名，也可以是用户定义数据类型

--查看对象
EXEC sp_helptext SalaryRule
/*第一句定义了一个规则叫SalaryRul
e 进行比较的事物是一个变量
这个变量的值是所检查的列的值
第二句把规则绑定到某个表的一个列上
规则和ckeck约束很相似，
但是规则只作用在一个列上
一个规则可以绑定在多个列上，但是它不会意识到其他列的存在
check可以定义column1>=column2
*/
--取消规则
exec sp_unbindrule 'Employee.Salary'
--删除规则
Drop rule SalaryRule

--默认值--------------------------------------------------------------------------------------------
--默认值与default约束类似（区别在于它们被追加一表中的方式和用户自定义数据类型的默认值（是对象，而不是约束）的支持）

create default salarydefault
as 0;
exec sp_binddefault 'salarydefault' , 'employee.salary';

--取消默认值：
exec sp_unbinddefault 'employee.salary'

--删除默认值：
drop default 'salarydefault'


EXEC sp_depends 'dbo.D_T_Numeric6'
