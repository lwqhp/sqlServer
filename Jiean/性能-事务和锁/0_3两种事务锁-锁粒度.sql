

--锁粒度------------------------------------------------------------------------------------
/*
如果说锁类型保证了事务访问的一致性，使得事务之间的以队列的方式访问资源，那么锁粒度则是“事务的隔离”，
代表事务所能申请到的锁资源，事务的范围越大，所需要申请的锁资源也就越多，大范围的长时间的锁资源以及锁级别的
提升是产生阻塞的根本原因。

（注：锁类型不会产生阻塞，锁类型是一个事务队列，锁类型只会让后面的事务队列处于“等待”状态，而不是阻塞，
阻塞是指已经获得执行权限，但在申请某些资源时得不到响应（资源被占用），而处于“阻塞”状态。）




--1）锁的粒度范围-------------------------------------------------------------------------------------

索引锁：KEY 锁定索引上的某一行或某个索引键，用于防止n读的索引行锁，也叫做键范围锁，这种锁类型使用范围和行组
		件，这个范围表示两个连续的索引键之间的索引键的范围，行组件表示索引实体上的锁类型。
行锁：RID 用于锁定堆中的某一行。
表锁：TABLE 锁定包括所有数据和索引的整个表。
页锁：PAGE 锁定数据库中的一个8KB页，例如数据页或索引页
范围锁：Extent 一组连续的8页
文件锁：FILE 锁定数据库文件
分区锁：HoBT 用于锁定表下面的某一个分区partition
数据库锁： DATABASE 锁定整个数据库

特殊锁：
应用程序专用锁：Application ：应用程序专用的资源
元数据锁：MetaDate
分配单元：Allocation_unit:一系列根据数据类型分组的相关页面，例如数据行，索引行，大型对象数据行

--2）锁的提升-----------------------------------------------------------------------------------

锁级别并不需要由用户来指定，锁管理器会自动确定，在访问少量行时，它一般首先行级和键锁以帮助并发，但如果多个行
锁的开锁变得很高，锁管理器自动选择合适的高级别锁。比如当单个t-sql语句在单个表或索引上获取5000多个锁或者sql
server实例 中的锁的数量超过可用内存阈值的时候，sqlserver会尝试启动锁升级。

执行一个查询时，sqlserver确定查询中引用的数据库对象所需要的锁级别，并且在获得必要的锁之后开始执行查询，在查
询执行期间，锁管理记录查询请求的锁数量，并且确定是否需要交从当前级别提升到更高级别。

可见，锁升级阈值由slqserver在事务期间动态确定，行锁和页面锁在事务超过阈值时自动升级为表锁，在锁升级到表级锁
时，所有该表上的较低级锁自动释放，锁管理器的动态锁升级特性优化了查询的加锁开销。（阈值5000）

应用申请的锁粒度越小，产生阻塞的概率就会越小，如果一个连接会经常申请页面级，表级，甚至数据库一级的锁资源，程序
产生阻塞的可能性就会越大。

a,一个事务内部要访问或者修改的数据量越大，它所要申请的锁的数目就会越多，粒度也就可能越大
b,一个事务做的事情越复杂，它要申请的锁的范围也就会越大
c,一个事务延续的时间越长，它持有的锁的时间也会越长。


--行锁------->

这是数据库上范围最小的锁，表示格式为：databaseID:fileID:pageID:slot(row)
slot(row)表示在该页面中该行的置
*/
SELECT * FROM sys.dm_tran_locks
SELECT OBJECT_NAME(281474979397632) --resource_associated_entity_id 表名
SELECT DB_NAME(14) --resource_database_id 数据库名

/*
--键锁，又叫索引锁------->

对于聚集索引，表的数据页面和聚集索引的叶子页面相同，因为表和聚集索引的行相同，从表或聚集索引中访问行时，在
该聚集索引行或有限范围的行中只能获得一个关键字锁。

如果表具有聚集索引，那么数据行就在聚集索引的叶级别并且是被键锁而不是行锁锁定的。


--索引上的锁
在堆表上，锁粒度为RID,PAG（在包含RID的页面上）和TAB表锁

因为非聚集索引的叶子页面与表的数据页面分离，与非聚集索引相关的资源也要同时受到保护而免被破坏。
所以更新会在包含非聚集索引的行的页面上IU锁，在索引页面中非聚集索引行上的U锁，当然，为了减少这种锁开销，也
可以显示关闭这些锁的申请

alter index i1 on t1
set (allow_row_locks = off,allow_page_locks =off)
--事务

alter index i1 on t1
set (allow_row_locks = on,allow_page_locks =on)

聚集索引的叶子页面和表的数据页面相同，聚集索引可以用于避免非聚集索引引入的额外的页面(叶子页面)和行的锁开锁
更新会在表上申请一个IX
包含该聚集索引行的页面上的一个IX
表(或聚集索引)中聚集索引行上的X

聚集索引行上和叶子页面上的锁实际上也是数据行和数据页面的上锁，因为数据页面和叶子页面相同，因此聚集索引和非取
集索引相比辣少了表上的锁的开锁。

*/
--查看键锁的特定资源
SELECT resource_description FROM sys.dm_tran_locks

/*
--页锁------->

申请一个8K页面锁，并标识为PAG锁。从查询计划中，锁管理器确定获得多个RID/KEY锁的资源压力如果压力较大，锁管理
器申请一个PAG锁来替代。

页级锁减少锁开销从而增进单个查询的性能，但是它阻塞该页面上所有行的访问从而损害数据库并发性。
格式：DatabaseID:fileID:pageID


--区锁，也叫范围锁------->

区是指一组连续8个8k的页面，这种锁用于在一个表上执行alter index rebuild命令并且该表从现有的区移动到新的区时，
在这期间，区的完整性用EXT锁来保护。


--堆或B-树锁------->

这是在堆或者B-树对象上的锁，通常指分区上的锁。


--表锁------->

在一个表上的表级锁保留了对整个表及其所有索引的访问，当执行一个查询时，锁管理器自动确定获得多个较低级别的锁
的开销，如果确定获取行级锁或页锁的资源压力较高，锁管理器直接为查询获取一个表级锁。

表级锁相对于其他锁来说需要的开销最少，从而改进了单个查询的性能，但同时，表锁阻塞整个表包括索引上的所有写
请求，它可能显著损害数据并发性。

格式：databaseID:objectID


--数据库锁------->

当应用程序建立一个数据库连接时，锁管理器分配一个据库共享锁给对应的spid,这阻止用户意外地在其他用户连接时载
或者恢复数据库。
*/



