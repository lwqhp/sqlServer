

--事务的级别
/*
事务的级别设定了事务隔离的等级，不同的隔离级别下，锁资源的申请会不同。

对于任何隔离级别，排它锁都要一直持续到事务结束为止，无论事务是被提交还是被回滚。更新锁也会持续到事
务结束，除非它被升级成了独占锁

1)未提交读级别--------------------------------------------------------------------------------
这是隔离级别中最低的，它允许select语句读取数据而不需要请求S锁，这也就不会被X锁阻塞，也不会去阻塞X锁
这种读出数据也被称为“脏读”（简单的说，就是一个进程更改了数据，在还没有提交更改时，另一个进程读取了
该数据）
*/

--SET语句配置
set transaction isolation level read uncommitted

--或者用nolock
select * from Bas_Company (nolock)

/*
2)已提交读--------------------------------------------------------------------------------
这是默认事务级别，select 会请求S锁，但不会保留到事务的结束（这种情况有可能会造成不可重复读或幻读）

也就是不能读取未提交的数据修改（当数据还是X锁时），反过来，当查询获取的数据时，其他进程也不能修改这笔记录。
只要涉及的行没有被第一个事务锁定，其他事务就能会同一个表进行数据插入和修改，这叫“不可重复读”（简单的说，就是
进程读在同一事务两次独立的读操作中读取相同的数据却取回不同的值，比如在第一个进程进行的两次读取之间，另一
个进程更改数据时就会发生这种情况。）

数据操纵事务使用行版本控制，这给tempdb带来一定的额外的负载，因为被修改的行的前一个版本在事务未提交时被保存在该
数据库里，这使其它事务可以读访问为九据不需要在数据上加锁，可能改进系统中所有查询的速度和效率。
*/

create database versionText

alter database versionTest 
	set read_committed_snapshot on --已提交读

/*
这也是为什么用begin tran 提交一个事务后，在当前连接可以看到修改的内容，而其它的连接看到的还是原来的内容
*/


--3)可重复读--------------------------------------------------------------------------------
/*
可重复读级别，它可以使一条select语句保持它的S锁直到事务结束，从而阻止其他事务在这段时间内修改该数据。

比如在一个事务中，你可能需要在前面查询出某个值，而后面又根据这个值用相同的查询条件去更新，如果在已
提交读级别中，就有可能会出现下一次按相同条件查询时，某个值已经被更新过了，要保持第一个事务中两次查询的
结查一致，就要隔离排它锁X对记录的更新。
*/
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
--事务
--处理完后设回已提交读
SET TRANSACTION ISOLATION LEVEL READ COMMITTED

--或者在表后加上(RepeaTableRead)

/*
这种通过提高事务级别在保证数据统一，会出现死锁问题，因为长时间保留S锁，而S锁不隔离U锁，当有其它更新语句
获取到了U锁后去因为不能把U锁转换为X锁而等待，而事务在后面想把S锁更新为U锁时又被另一事务阻塞，最终造成死锁，
（这也是为什么更新要U锁而不是S锁的原因）。
较好的解决方法是在一条语句中完成数据的查询和更新，如查一定要分两个语句执行，则前一个语句中直接申请U锁而不是S锁
select * from bas_company (updlock)
*/

--4)可序列化--------------------------------------------------------------------------------
/*
这是事务级别中的最高级别，它不仅保留S锁，而且在访问的行上获取一个锁，和在该行以及按照请求的数据级顺序的下一
个行上的范围锁。这可以防止幻读（在事务内的数据集中查找新建的行）
比如在第一个事务中进行查询出来的数据，进行加工后，在后面的语句中再按同样的查询条件来更新，这就有可能出现在
加工阶段，有新的数据插入进来了，在后面的语句中统计的数量就不能按前面统计好的数量来计算。


*/

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
--事务
--还原回已提交读
SET TRANSACTION ISOLATION LEVEL READ COMMITTED 

--或者在第一个语句查询表时加上(holdlock)

/*
可序列化读有两个副作用
1,在事务期间，其它事务不能向表添加记录
2,如果事务的数据集变成按照索引排序的已存在数据的最后一个集合，那么，数据集行上(该行位于数据集最后一行的
后面)需要的范围锁，在表中最后一个可能的数据值上获取，在聚集索引中最后一个可能的行上(key=fffffffff)的范围锁
将阻塞该表添加新行。
*/

--5）快照SnapHot
/*
这是sqlServer中可用的第二种行版本控制隔离级别，和已提交读快照隔离不同，快照隔离级别要求在事务开始时除了在数
据库上设置隔离级别之外，还要显式调用 set transaction isolaction level 。快照隔离将试图在打算修改的数据上使用一
个排他锁，如果数据已经加锁，快照事务将失败。

这个隔离级别允许我们读取事务一致性版本的数据，因为它存在于一个事务的开始阶段。数据读取不阻塞数据修改，然而，
snaphot会话不能检测到当前的修改。(即使在第二个查询中更新了该行，这个查询还是返回了和前面第一个事务的相同结果
select没有因为读取行而被阻塞，而update也没有被阻塞进行修改)
*/
ALTER DATABASE AdventureWorks
SET ALLOW_SNAPSHOT_ISOLATION ON
go
USE AdventureWorks
go

SET TRANSACTION ISOLATION LEVEL snaphot
go


-----行版本控制-----------------------------------------------------------------
/*
行版本控制：启用数据库选项， sqlserver在tempdb中启用一部份存储空间作为版本存储区，用来存储所有发生更改的
行的副本，并且将这些副本一直保存到没有任何事务需要访问它们为止。

这是区别于快照SnapHot的快照隔离级别，叫已提交读快照隔离级别（RCSI），只要通过设置一个数据库选项就可以启用，
一旦启用，无需做进一步的更改。任何应该在默认已提交读隔离级别下运行的事务都将运行在RCSI下。

RCSI ：表示任何查询都看到语句开始时最近提交的值。
	比如 事务A 更新V值，事务B中可以看到V未更新的值，以及在A事务提交后的最新V值。
RCSI优势：在该模式下可以引入更大的并发性，因为读取者不阻塞写入者，写入者也不阻塞读取者。但是，写入者会阻塞
写入者，因为通常的锁定行为适用于所有update,insert ,delete 操作。

与快照隔离级别的区别是：
	事务A 更新V值，事务B中只能看到V未更新的值，只有以B事务外才可以看到V的最新值(事务A已经提交)


RCSI和SI的比较
	RCSI比SI消耗的tempdb空间少
	RCSI适合于分布式事务，SI不适合
	RCSI不产生更新冲突

快照隔离级别的代价：
当必须扫描长的版本链时，select 性能会受到负面影响，快照越老，在SI事务中访问所需的行花费的时间就越长。
行版本控制需要tempdb中的额外资源
数据操作会产生行版本，会让操作语句变慢。
*/







