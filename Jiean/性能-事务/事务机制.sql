

--事务

/*
如果有人问你什么事务，你或许很容易解释，因为事务我们日常使用到。

事务就是作为单个‘逻辑工作单元’执行的一系列操作。一个select 语句，一个begin tran 都是一个事务。
事务具有ACID特性
1）原子性：要么全部执行，要么全都不执行。
2）一致性：事务在完成时，必须使所有的数据都保持一致状态。
3）隔离性：同一时间，只能有一个事务修改当前数据。
4）持久性：事务完成后，它对系统的影响是永久性的

?但在业务中，我们遇到更多的问题是阻塞和死锁，

锁是事务隔离的一部份，sqlServer通过不同的资源申请不同的锁，然后针对锁的状态定义隔离级别和访问方法。
阻塞进事务隔离的体现，锁的粒度，时间是阻塞的源头。

在实际应用中，我们心中必须要有谱的是:
事务会产生什么锁，锁的范围有多大。时间有多久，其它那些事务产生的锁是兼容的。

1）锁的粒度范围
索引锁：KEY 锁定索引上的某一行或某个索引键
行锁：RID 用于锁定堆中的某一行。
表锁：TABLE 锁定包括所有数据和索引的整个表。
页锁：PAGE 锁定数据库中的一个8KB页，例如数据页或索引页
范围锁：Extent 一组连续的8页
文件锁：FILE 锁定数据库文件
分区锁：HoBT 用于锁定表下面的某一个分区partition
数据库锁： DATABASE 锁定整个数据库

特殊锁：
应用程序专用锁：Application
元数据锁：MetaDate
分配单元：Allocation_unit

2) 锁的名称
共享锁(S) 赋予不更改或不更新数据的读取操作，比如select 
更新锁(U) 赋予更新语句，防止当多个会话在读取，锁定以及随后可能进行的资源更新时发生常见形式的死锁
排他锁(X) 赋予数据修改操作语句，比如insert ,update,delete,确保不会同时对同一资源进行多重更新
架构锁    赋予表架构操作语句，架构锁包含 两种类型：架构修改（sch-M）和架构稳定性(sch-S)
大容量更新锁(BU) 在向表进行大容量数据复制且指定了TABLOCK提示时使用
键范围 当使用可序列化事务隔离级别时何护查询读取的行的范围，确保再次运行查询时其它事务无法插入符合可序列化事务的查询的行。

意向锁：由其它锁请求产生，位于资源层次结构这一级别上的锁，用于锁申请，和等待阶段，以及锁的检查，事务不必检查表内各个页锁，只需要查
表上的意向锁即可，以提升性能。
包括 意向共享锁(IS),意向排他锁(IX) 和意向排他共享锁(SIX)


3)锁的控制等级
共享锁S：允许并发事务在封闭式并发控制下读取select资源，资源上存在共享锁时，任何其它事务都不能修改数据。

更新锁U：一次只有一个事务可以获得资源的更新锁，事务真正修改数据时，将更新锁转换为排他锁。

排他锁X：任何其它事务都无法读取或者修改数据，仅在使用 nolock提示或未提交读隔离级别时才会进行读操作。

意向锁I :意向锁可防止其它事务随后在表上提升锁请求，保护事务资源的完整性。

4）锁的粒度效应

应用申请的锁粒度越小，产生阻塞的概率就会越小，如果一个连接会经常蝇请页面级，表级，甚至数据库一级的锁资源，程序
产生阻塞的可能性就会越大。

a,一个事务内部要访问或者修改的数据量越大，它所要申请的锁的数目就会越多，粒度也就可能越大
b,一个事务做的事情越复杂，它要申请的锁的范围也就会越大
c,一个事务延续的时间越长，它持有的锁的时间也会越长。


5)并发控制：使一个人所做的修改不会对他人所做的修改产生负面影响。

*/