

--事务的级别
/*
事务的级别设定了事务隔离的级别，不同的隔离级别下，锁资源的申请会不同，跟隔离的范围有些区别

1)未提交读级别--------------------------------------------------------------------------------
这是隔离级别中最低的，它允许select语句读取数据而不需要请求S锁，这也就不会被X锁阻塞，也不会去阻塞X锁
这种讯出数据也被称为脏读
*/

--SET语句配置
set transaction isolation level read uncommitted

--或者用nolock
select * from Bas_Company (nolock)

/*
2)已提交读--------------------------------------------------------------------------------
这是默认事务级别，select 会请求S锁，但不会保留到事务的结束（这种情况有可能会造成不可重复读或幻读）

数据操纵事务使用行版本控制，这给tempdb带来一定的额外的负载，因为被修改的行的前一个版本在事务未提交时被保存在该
数据库里，这使其它事务可以读访问为九据不需要在数据上加锁，可能改进系统中所有查询的速度和效率。
*/

create database versionText

alter database versionTest 
	set read_committed_snapshot on --已提交读

/*
这也是为什么用begin tran 提交一个事务后，在当前连接可以看到修改的内容，而其它的连接看到的还是原来的内容
*/


--3)可重复读--------------------------------------------------------------------------------
/*
可重复读级别，它可以使一条select语句保持它的S锁直到事务结束，从而阻止其他事务在这段时间内修改该数据。

比如在一个事务中，你可能需要在前面查询出某个值，而后面又根据这个值用相同的查询条件去更新，如果在已
提交读级别中，就有可能会出现下一次按相同条件查询时，某个值已经被更新过了，要保持第一个事务中两次查询的
结查一致，就要隔离排它锁X对记录的更新。
*/
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
--事务
--处理完后设回已提交读
SET TRANSACTION ISOLATION LEVEL READ COMMITTED

--或者在表后加上(RepeaTableRead)

/*
这种通过提高事务级别在保证数据统一，会出现死锁问题，因为长时间保留S锁，而S锁不隔离U锁，当有其它更新语句
获取到了U锁后去因为不能把U锁转换为X锁而等待，而事务在后面想把S锁更新为U锁时又被另一事务阻塞，最终造成死锁，
（这也是为什么更新要U锁而不是S锁的原因）。
较好的解决方法是在一条语句中完成数据的查询和更新，如查一定要分两个语句执行，则前一个语句中直接申请U锁而不是S锁
select * from bas_company (updlock)
*/

--4)可序列化--------------------------------------------------------------------------------
/*
这是事务级别中的最高级别，它不仅保留S锁，而且在访问的行上获取一个锁，和在该行以及按照请求的数据级顺序的下一
个行上的范围锁。这可以防止幻读（在事务内的数据集中查找新建的行）
比如在第一个事务中进行查询出来的数据，进行加工后，在后面的语句中再按同样的查询条件来更新，这就有可能出现在
加工阶段，有新的数据插入进来了，在后面的语句中统计的数量就不能按前面统计好的数量来计算。
*/

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
--事务
--还原回已提交读
SET TRANSACTION ISOLATION LEVEL READ COMMITTED 

--或者在第一个语句查询表时加上(holdlock)

/*
可序列化读有两个副作用
1,在事务期间，其它事务不能向表添加记录
2,如果事务的数据集变成招按照索引排序的已存在数据的最后一个集合，那么，数据集行上(该行位于数据集最后一行的
后面)需要的范围锁，在表中最后一个可能的数据值上获取，在聚集索引中最后一个可能的行上(key=fffffffff)的范围锁
将阻塞该表添加新行。
*/

--快照
/*
这是sqlServer中可用的第二种行版本控制隔离级别，和已提交读快照隔离不同，快照隔离级别要求在事务开始时除了在数
据库上设置隔离级别之外，还要显式调用 set transaction isolaction level 。快照隔离将试图在打算修改的数据上使用一
个排他锁，如果数据已经加锁，快照事务将失败。
*/

--索引上的锁
/*
在堆表上，锁粒度为RID,PAG（在包含RID的页面上）和TAB表锁

因为非聚集索引的叶子页面与表的数据页面分离，与非聚集索引相关的资源也要同时受到保护而免被破坏。
所以更新会在包含非聚集索引的行的页面上IU锁，在索引页面中非聚集索引行上的U锁，当然，为了减少这种锁开销，也
可以显示关闭这些锁的申请
*/
alter index i1 on t1
set (allow_row_locks = off,allow_page_locks =off)
--事务

alter index i1 on t1
set (allow_row_locks = on,allow_page_locks =on)

/*
聚集索引的叶子页面和表的数据页面相同，聚集索引可以用于避免非聚集索引引入的额外的页面(叶子页面)和行的锁开锁
更新会在表上申请一个IX
包含该聚集索引行的页面上的一个IX
表(或聚集索引)中聚集索引行上的X

聚集索引行上和叶子页面上的锁实际上也是数据行和数据页面的上锁，因为数据页面和叶子页面相同，因此聚集索引和非取
集索引相比辣少了表上的锁的开锁。
*/




