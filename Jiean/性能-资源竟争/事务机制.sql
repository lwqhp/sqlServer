

--事务

/*
如果有人问你什么事务，你或许很容易解释，因为事务我们日常使用到。

事务就是作为单个‘逻辑工作单元’执行的一系列操作。一个select 语句，一个begin tran 都是一个事务。
事务具有ACID特性
1）原子性：要么全部执行，要么全都不执行。
2）一致性：事务在完成时，必须使所有的数据都保持一致状态。
3）隔离性：同一时间，只能有一个事务修改当前数据。
4）持久性：事务完成后，它对系统的影响是永久性的

*/
--4.1）原子性------------------------------------------------------------------------------------------------
/*一条查询语句就是一个独立的逻辑工作单元，具有完整的原子性，比如insert操作，只要有一笔记录失败，整
个插入更作都会失败
begin tran开启一个事务，事务只负责把多个语句作业一个大的逻辑工作单元，统一是提交还是回滚，但sqlserver
默认的错误机制并不会影响各语句的执行，除非错误级别在16以上的致命错误，执行强制退出，否则事务会继续往
下执行

*/
BEGIN TRAN 
SELECT 1/0
SELECT * FROM dbo.eee
COMMIT TRAN 
SELECT @@trancount

/*有两个方法可以觖决这个问题：
1）显示声明事务级别 
Set Xact_abort_on 在事务中有语句失败时自动回滚

2)显式捕捉错误并回滚，比如@@error,begin try */


--4.2）一致性产生阻塞-----------------------------------------------------------------------------------------
/*
是指一个逻辑工作单元使数据库的状态从一个一致状态转换到另一个一致状态，在事务结束时，不管是提交，还是回滚，
事务对数据库的影响是一致的。也就是说，当事务开启时，查询所要使用的对象将被隔离，直到所有的事务完成。
当然，这只是理想的执行过程中没有任何的错误发生。
*/

--4.3）隔离性------------------------------------------------------------------------------------------------
/*隔离，是对事务的隔离，因为事务通常是多语句的工作单元，必须对共同占用的资源的事务进行隔离，以保证事务的
一致性，可见，事务的范围越大，受影响的事务也就越大。（经常出现阻塞，会不会就是事务的范围太大了啊）*/

--4.4）持久性------------------------------------------------------------------------------------------------
/*
事务完成时，对数据库所做的操作是持久的，这意味着，当事务完成时，会将所有所做的修改写到事务日志中，并写入
磁盘日志文件，并在下一个checkpoint点，把修改数据更新磁盘数据文件，这里叫下‘前滚’：当事务已完成，但内存中的
数据还没有更新到磁盘上时，出现的意外造成数据库死机或重启，在重启期间，sqlserver会根据日志文件重写磁盘数据文件
，以保存日志文件和数据文件的状态一致，这就叫前滚。
*/

/*
总结：原子性会影响事务内语句的执行过程，所以要做好语句的业务逻辑以及错语处理
一致性和隔离性在资源和事务上产生隔离，占用过长时间的资源以及事务的范转过大，都会产生阻塞
持久性虽不会直接产生阻塞，但因持久性要求在磁盘上的事务日志中保存数据修改前后的映像，这增加了事务和阻塞的持续时间。
*/

?但在业务中，我们遇到更多的问题是阻塞和死锁，

锁是事务隔离的一部份，sqlServer通过不同的资源申请不同的锁，然后针对锁的状态定义隔离级别和访问方法。
阻塞进事务隔离的体现，锁的粒度，时间是阻塞的源头。

在实际应用中，我们心中必须要有谱的是:
事务会产生什么锁，锁的范围有多大。时间有多久，其它那些事务产生的锁是兼容的。

1）锁的粒度范围
索引锁：KEY 锁定索引上的某一行或某个索引键
行锁：RID 用于锁定堆中的某一行。
表锁：TABLE 锁定包括所有数据和索引的整个表。
页锁：PAGE 锁定数据库中的一个8KB页，例如数据页或索引页
范围锁：Extent 一组连续的8页
文件锁：FILE 锁定数据库文件
分区锁：HoBT 用于锁定表下面的某一个分区partition
数据库锁： DATABASE 锁定整个数据库

特殊锁：
应用程序专用锁：Application
元数据锁：MetaDate
分配单元：Allocation_unit

2) 锁的名称
共享锁(S) 赋予不更改或不更新数据的读取操作，比如select 
更新锁(U) 赋予更新语句，防止当多个会话在读取，锁定以及随后可能进行的资源更新时发生常见形式的死锁
排他锁(X) 赋予数据修改操作语句，比如insert ,update,delete,确保不会同时对同一资源进行多重更新
架构锁    赋予表架构操作语句，架构锁包含 两种类型：架构修改（sch-M）和架构稳定性(sch-S)
大容量更新锁(BU) 在向表进行大容量数据复制且指定了TABLOCK提示时使用
键范围 当使用可序列化事务隔离级别时何护查询读取的行的范围，确保再次运行查询时其它事务无法插入符合可序列化事务的查询的行。

意向锁：由其它锁请求产生，位于资源层次结构这一级别上的锁，用于锁申请，和等待阶段，以及锁的检查，事务不必检查表内各个页锁，只需要查
表上的意向锁即可，以提升性能。
包括 意向共享锁(IS),意向排他锁(IX) 和意向排他共享锁(SIX)


3)锁的控制等级
共享锁S：允许并发事务在封闭式并发控制下读取select资源，资源上存在共享锁时，任何其它事务都不能修改数据。

更新锁U：一次只有一个事务可以获得资源的更新锁，事务真正修改数据时，将更新锁转换为排他锁。

排他锁X：任何其它事务都无法读取或者修改数据，仅在使用 nolock提示或未提交读隔离级别时才会进行读操作。

意向锁I :意向锁可防止其它事务随后在表上提升锁请求，保护事务资源的完整性。

4）锁的粒度效应

应用申请的锁粒度越小，产生阻塞的概率就会越小，如果一个连接会经常蝇请页面级，表级，甚至数据库一级的锁资源，程序
产生阻塞的可能性就会越大。

a,一个事务内部要访问或者修改的数据量越大，它所要申请的锁的数目就会越多，粒度也就可能越大
b,一个事务做的事情越复杂，它要申请的锁的范围也就会越大
c,一个事务延续的时间越长，它持有的锁的时间也会越长。


5)并发控制：使一个人所做的修改不会对他人所做的修改产生负面影响。

*/