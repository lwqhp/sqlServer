

--锁资源争用
/*
sqlServer通过对不同的请求类型，分配相应的锁资源，以协调各个事务对资源的排队使用。


sqlServer中有3种类型的锁，操作锁，意向锁和架构锁
3.1）操作锁
共享锁(S) 赋予不更改或不更新数据的读取操作，比如select 
更新锁(U) 赋予更新语句，防止当多个会话在读取，锁定以及随后可能进行的资源更新时发生常见形式的死锁
排他锁(X) 赋予数据修改操作语句，比如insert ,update,delete,确保不会同时对同一资源进行多重更新

架构锁    赋予表架构操作语句，架构锁包含 两种类型：
架构修改（sch-M）和架构稳定性(sch-S)
Sch-S 表示一个使用该的查询正在被编译
Sch-M 表示表的结构正在被修改

大容量更新锁(BU) 在向表进行大容量数据复制且指定了TABLOCK提示时使用
键范围 当使用可序列化事务隔离级别时何护查询读取的行的范围，确保再次运行查询时其它事务无法插入符合可序列化事务的查询的行。

意向锁：由其它锁请求产生，位于资源层次结构这一级别上的锁，用于锁申请，和等待阶段，以及锁的检查，事务不必检查表内各个页锁，只需要查
表上的意向锁即可，以提升性能。
包括 意向共享锁(IS),意向排他锁(IX) 和意向排他共享锁(SIX)


3)锁的控制等级
共享锁S：允许并发事务在封闭式并发控制下读取select资源，资源上存在共享锁时，任何其它事务都不能修改数据。

更新锁U：一次只有一个事务可以获得资源的更新锁，事务真正修改数据时，将更新锁转换为排他锁。

排他锁X：任何其它事务都无法读取或者修改数据，仅在使用 nolock提示或未提交读隔离级别时才会进行读操作。

意向锁I :意向锁可防止其它事务随后在表上提升锁请求，保护事务资源的完整性。


*/

--共享锁S
/*
只读查询会分配共享锁，它不会阻止其他只读查询同时访问数据，因为数据完整性不会被并发读破坏。
但是数据上的并发数据修改将被阻止以维护数据完整性。

的默认隔离级别 read_committed下，共享锁是在数据读出后就立即释放，而不会等到事务完成。
{允许其他进程读取但不能修改锁定的资源}
*/

--更新锁U
/*
更新有两个操作过程：读取和修改

读取操作会分配U更新锁,U锁兼容S锁，但隔离其它U锁，同样，U锁会存在于读取经过的数据当中，当不是需要修改的数
据时，U锁会被释放，而不会等到事务的结束。
如果数据为需要修改的数据，则U锁会转换为X锁。
{防止其他进程获得更新锁或独占锁，在搜索要修改的数据时使用}
*/


--排它锁X
/*
排它锁阻止其它事务访问修改之下的资源，insert和delete语句在执行的开始获取X锁，update则是在被修改的数据读出
后转换为X锁，在事务中，X锁被保持到事务结束。

X锁目的：
1）阻止其他事务访问修改之下的资源这样它们可以看到修改之前或之后的值，而不是正在修改的值
2）在需要时允许事务修秘诀资源以安全地回滚到修改之前的原始值因为没有其他事务被允许同时修改资源。
{防止别的进程修改或者读取锁定资源中的数据}
*/

--意向锁
/*
指出在查询有较低的锁级别上获取对应的s,x锁的意向，在更范围上的ix锁阻止其他事务获取包含该行的表或者页面上不兼容的锁
{
只有在表或页级别才能获得这类锁
IS 表示该资源的一个组件被共享锁锁定了
IX 表示该资源的一个组件被排它锁锁定了
IU 表示该资源的一个组件被更新锁锁定了
SIX,SIU,UIX 表示一个正持有共享锁的资源还有一个组件(一页或一行)被更新锁锁定了}
*/

--大容量更新(BU)模式
/*
大容量更新锁模式只用于大负载操作，这些操作是老式的bcp,bulk insert 语句，以及使用bulk选项的openrowset插入，作为加速
这些操作的一种机制，可以提供一个tablock提示或设置该表上的选项来锁定大量的负载。(BU)锁模式的关键是它允许针对所定标的
多个批量操作，但是在运行过程当中阻止其他操作。
{在一个大容量复制操作将数据导入表中并且应用了tablock查询提示时使用}
*/

/*
排它锁锁定的资源不能再加其他锁，其他事务必须等待或超时，直到排它锁被释放
被更新锁锁定的资源只能接受其他事务的共享锁。
被共享锁锁定的资源还能接受其他 共享锁或更新锁。
*/



---第二种类型的锁
/*
系统内部用于索引并发控制，控制对内部数据结构的访问，以及检索单个数据行页面。叫闩锁。
*/