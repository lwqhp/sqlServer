


--日志文件的使用情况 ---------------------------------------------------------------------------
DBCC SQLPERF(LOGSPACE)

--TempDB的空间使用---------------------------
/*
tempdb保存的对象
1）用户对象
由用户显式创建，在用户会话中创建，或者是在用户例程(存储过程，触发器和用户定义函数)中创建，这些对象包含 ：
	用户定义的表和索引
	系统表和索引
	全局临时表和索引
	局部临时表和索引
	@table变量
	表值函数中返回的表

2）内部对象
 sqlserver用于处理sqlserver语句而创建的对象，包含：
	用于游标或假脱机操作以及临时大型对象(LOB)存储的工作表。
	用于哈希连接或哈希聚合操作的工作文件
	用于创建或重新生成索引等操作(如果指定了sort_in_tempdb)的中间排序结果，或者某些group by ,order by ，union 查询的中间排序结果。
	
每个内部对象致少使用9页，一个IAM页，8个页的区。

3）版本存储区
版本存储区是数据页的集合，它包含支持使用行版本控制的功能所需的数据行，主要用来支持快照事务隔离级别，以及一些
其它提高数据库并发度的新功能。
*/

--返回所有做过空间申请的会话信息
SELECT * FROM sys.dm_db_file_space_usage

--tempdb空间的总体分配
SELECT * FROM sys.dm_db_session_space_usage t1,sys.dm_exec_sessions t3
WHERE t1.session_id = t3.session_id


/*
通过观察分析 了解系统的空间使用需求，提前规划并引导数据的流向，尽量避免空间用尽面使得sqlserver不得不自动增长的现
象发生同是要确保每一次自动增长能够在可接受的时间内完成，及时满足用户端的应用需求。

数据库创建之初，定义数据文件的初始大小，是否自动增长及最大值。当数据文件写满以后，会按自动增长的比例增加文件的大小。

为了分散i/0负载，把一个文件组中多个数据库文件放在不同的硬盘上，但需要对数据文件必须保证同一个文件组里的所有数据
文件都有基本一样大小的空闲空间（不是这这些文件一样大就可以的），如果某个硬盘上的数据文件已经被写满了，sqlserver就
不会再往这个硬盘上写了，如果空闲空间相对比较少，sqlserver写的数目也会相对减少。因为当文件全部写满了，sqlserver会选
取其中任意一个数据文件做自动增长，而不是让每一个数据文件都做自动增长，所有后面的数据都写入这个做了自动增长的文件里，
直到这个文件再次写满，sqlserver要做下一次自动增长为止。

日志文件，sqlserver自动增长当前的日志文件，以保证日志记录的连续性，多个日志文件对性能基本不会有什么帮助。

自动收缩选项：sqlserver每隔半个小时会检查文件使用情况，如果空闲空间大于25%,sqlserver会自动运行dbcc shrinkfile的动作。

设置：
1，设置成按固定大小增长，页不能按比例，避免一次增长太多或者太少所带来的不必要的麻烦，小库设置一次增长 50到100m,大库100-200M
2,定期监测各个数据文件的使用情况，尽量保证每个文件剩余的空间一样大，或者是期望的比例。
3，设置文件最大值，以名 sqlserver文件自动增长用尽磁盘空间，影响操作系统。
4，发生自动增长后，要及时检查新的数据文件空间分配情况，避免sqlserver总是往个别文件写数据。
5，数据文件收缩会给文件带来更多的碎片。
6，尽量不要使用自动收缩功能。

？为什么日志文件这么大
日志文件记录了所有的修改动作，以便将来重新提交或者回滚时使用，但日志文件是循环使用的，是什么造成有这么大的日志文件

sqlServer需要使用中的日志数据
1，所有没有经过“检查点”的日志记录
sqlserver定期做检查点，保证所有的“脏页”都被写入硬盘未做检查点的修改，可能仅是内存中的修改，数据文件里还没有同步，
sqlserver是硬盘上的日志文件里有一份记录，以便在异常重启后重新修改。

2，所有没有提效的事务所产生的日志记录，以及在它们之后的所有日志记录。
如果数据库有没有提交的事务，sqlserve会标记所有从这个事务开始的日志记录（不管和这个事务有没有关系）为活动辐务日志，
这些日志记录都有可能“需要”被用来做回滚。

3，所有要做备份的日志记录
如果数据库设的恢复模式不是简单模式，sqlserver就假设用户是要去备份日志记录的，所有未被备份的记录，sqlserver会为用户保留，
哪怕这些记录对数据库本身已经没有其他用途了。

4，有其它需要读取日志的数据库功能模块。
比如事务型复制和数据库镜像，也需要读取日志文件中的内容，完成它们的同步工作，在这些功能组件没有读取日志记录之前，sqlserver也会保留。

>>>只有检查点对所有“不需要”的日志记录做日志截断后，被截断部份的日志空间才可以循环使用。

那会有那些情况影响检查点来（Recovery interval默认一分钟做一次检查）时，日志还是需要的
1，数据库恢复模式不是简单模式，但是没有安排日志备份
只有做完日志备份后记录才能被截断，做完整备份和差异备份都不会起这个作用。

2，数据库上面有一段很长时间都没有提效的事务。
比如遗留了事务在sqlsever里面，没有及时提效它，sqlserver是不会干预用户的这种行为的，只要这个连接不退出，这个事务会永运存在，直到客户
端主动提效或者回滚它，从这个事务开始的那个时间点开始的所有日志记录，sqlserver都会保留(做过日志备份也没用)。


3，数据库上有一个很大的事务正在运行。
比如某个用户正在建立、重建索引，或者用delete/insert语句删除或插入大量数据，或者用户端开了一个服务器商游标介是没有把数据及时取走等。

4，数据库复制或者镜像出了异常
*/

--检查日志现在使用情况和数据库状态

DBCC SQLPERF(LOGSPACE)
GO
SELECT 
name,recovery_model_desc,log_reuse_wait,log_reuse_wait_desc--反映sqlserver认为的不能截断日志的原因
 FROM sys.databases
 
 --检查最老的活动事务
 /*
 如果大部份日志在使用中，而且日志重用等待状态是active_transaction,那么要看这个数据库最久未提交的事务到底是由
 谁申请的
 */
 
 --返回正在运行并且做过空间申请的会话正在运行的语句
SELECT * FROM sys.dm_db_session_space_usage t1,
sys.dm_exec_requests t4
CROSS APPLY sys.dm_exec_sql_text(t4.sql_handle) st
WHERE t1.session_id = t4.session_id
AND t1.session_id>50

 DBCC OPENTRAN
 GO
 SELECT * FROM sys.dm_exec_sessions t2,sys.dm_exec_connections t1
 CROSS APPLY sys.dm_exec_sql_text(t1.most_recent_sql_handle) st
 WHERE t1.session_id = t2.security_id
 AND t1.session_id >50
 


 /*
 再次运行dbcc opentran,命令会返回下一个最久未提交的事务，直到所有的事务被提交或回滚完毕为止。
 */
 
 /*
分析日志使用
1，设置tempdb的自动增长
2，模拟各个单独的查询或工作任务，同时临视tempdb 空间使用
3，模拟执行一些系统维护操作，例如重新生成索引，同时临视tempdb空间
4，使用2,3中tempdb空间使用值 来预测总的工作负荷下，会使用多少空间，并针对计划的并发度调整 此值。比如，如果一个
任务会使用10GB的tempdb空间，而在生产环境里最多可能会有4个这样的任务同时运行，那要至少预留40GB的空间。
5，根据4得到的值，设置tempdb在生产环境下的初始大小，同时也开启自动增长。
*/